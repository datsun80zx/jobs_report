// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analytics.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const getConversionRateByTechnician = `-- name: GetConversionRateByTechnician :many
SELECT 
    t.technician_id,
    t.technician_name,
    COUNT(DISTINCT e.estimate_id) as total_estimates,
    COUNT(DISTINCT CASE WHEN e.is_sold THEN e.estimate_id END) as sold_estimates,
    CASE 
        WHEN COUNT(DISTINCT e.estimate_id) > 0 
        THEN ROUND(100.0 * COUNT(DISTINCT CASE WHEN e.is_sold THEN e.estimate_id END) / COUNT(DISTINCT e.estimate_id), 2)
        ELSE 0 
    END as conversion_rate
FROM technician t
LEFT JOIN job j ON t.technician_id = j.sold_by_technician_id
LEFT JOIN estimate e ON j.job_id = e.job_id
GROUP BY t.technician_id, t.technician_name
HAVING COUNT(DISTINCT e.estimate_id) > 0
ORDER BY conversion_rate DESC
`

type GetConversionRateByTechnicianRow struct {
	TechnicianID   int32  `json:"technician_id"`
	TechnicianName string `json:"technician_name"`
	TotalEstimates int64  `json:"total_estimates"`
	SoldEstimates  int64  `json:"sold_estimates"`
	ConversionRate int32  `json:"conversion_rate"`
}

func (q *Queries) GetConversionRateByTechnician(ctx context.Context) ([]GetConversionRateByTechnicianRow, error) {
	rows, err := q.db.QueryContext(ctx, getConversionRateByTechnician)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConversionRateByTechnicianRow
	for rows.Next() {
		var i GetConversionRateByTechnicianRow
		if err := rows.Scan(
			&i.TechnicianID,
			&i.TechnicianName,
			&i.TotalEstimates,
			&i.SoldEstimates,
			&i.ConversionRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerLifetimeValue = `-- name: GetCustomerLifetimeValue :one
SELECT 
    c.customer_id,
    c.customer_name,
    COUNT(DISTINCT j.job_id) as total_jobs,
    COALESCE(SUM(jfs.revenue), 0) as lifetime_revenue
FROM customer c
LEFT JOIN job j ON c.customer_id = j.customer_id
LEFT JOIN vw_job_financial_summary jfs ON j.job_id = jfs.job_id
WHERE c.customer_id = $1
GROUP BY c.customer_id, c.customer_name
`

type GetCustomerLifetimeValueRow struct {
	CustomerID      int32       `json:"customer_id"`
	CustomerName    string      `json:"customer_name"`
	TotalJobs       int64       `json:"total_jobs"`
	LifetimeRevenue interface{} `json:"lifetime_revenue"`
}

func (q *Queries) GetCustomerLifetimeValue(ctx context.Context, customerID int32) (GetCustomerLifetimeValueRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerLifetimeValue, customerID)
	var i GetCustomerLifetimeValueRow
	err := row.Scan(
		&i.CustomerID,
		&i.CustomerName,
		&i.TotalJobs,
		&i.LifetimeRevenue,
	)
	return i, err
}

const getJobCountByStatus = `-- name: GetJobCountByStatus :many
SELECT 
    job_status,
    COUNT(*) as job_count
FROM job
GROUP BY job_status
ORDER BY job_count DESC
`

type GetJobCountByStatusRow struct {
	JobStatus string `json:"job_status"`
	JobCount  int64  `json:"job_count"`
}

func (q *Queries) GetJobCountByStatus(ctx context.Context) ([]GetJobCountByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobCountByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobCountByStatusRow
	for rows.Next() {
		var i GetJobCountByStatusRow
		if err := rows.Scan(&i.JobStatus, &i.JobCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobFinancialSummary = `-- name: GetJobFinancialSummary :one

SELECT job_id, job_subtotal, job_total, revenue, is_zero_dollar_job FROM vw_job_financial_summary WHERE job_id = $1
`

// =====================================================
// ANALYTICAL QUERIES
// =====================================================
func (q *Queries) GetJobFinancialSummary(ctx context.Context, jobID int32) (VwJobFinancialSummary, error) {
	row := q.db.QueryRowContext(ctx, getJobFinancialSummary, jobID)
	var i VwJobFinancialSummary
	err := row.Scan(
		&i.JobID,
		&i.JobSubtotal,
		&i.JobTotal,
		&i.Revenue,
		&i.IsZeroDollarJob,
	)
	return i, err
}

const getJobWithFinancials = `-- name: GetJobWithFinancials :one
SELECT 
    j.job_id, j.job_type_id, j.business_unit_id, j.customer_id, j.location_id, j.project_id, j.job_campaign_id, j.call_campaign_id, j.job_status, j.priority, j.summary, j.job_creation_date, j.job_schedule_date, j.job_completion_date, j.scheduled_time, j.first_dispatch_date, j.hold_date, j.start_of_work_time, j.end_of_work_time, j.booked_by_user_id, j.dispatched_by_user_id, j.sold_by_technician_id, j.is_warranty, j.warranty_for_job_id, j.is_recall, j.recall_for_job_id,
    jfs.job_subtotal,
    jfs.job_total,
    jfs.revenue,
    jfs.is_zero_dollar_job
FROM job j
LEFT JOIN vw_job_financial_summary jfs ON j.job_id = jfs.job_id
WHERE j.job_id = $1
`

type GetJobWithFinancialsRow struct {
	JobID              int32          `json:"job_id"`
	JobTypeID          int32          `json:"job_type_id"`
	BusinessUnitID     int32          `json:"business_unit_id"`
	CustomerID         int32          `json:"customer_id"`
	LocationID         int32          `json:"location_id"`
	ProjectID          sql.NullInt32  `json:"project_id"`
	JobCampaignID      sql.NullInt32  `json:"job_campaign_id"`
	CallCampaignID     sql.NullInt32  `json:"call_campaign_id"`
	JobStatus          string         `json:"job_status"`
	Priority           sql.NullString `json:"priority"`
	Summary            sql.NullString `json:"summary"`
	JobCreationDate    time.Time      `json:"job_creation_date"`
	JobScheduleDate    sql.NullTime   `json:"job_schedule_date"`
	JobCompletionDate  sql.NullTime   `json:"job_completion_date"`
	ScheduledTime      sql.NullTime   `json:"scheduled_time"`
	FirstDispatchDate  sql.NullTime   `json:"first_dispatch_date"`
	HoldDate           sql.NullTime   `json:"hold_date"`
	StartOfWorkTime    sql.NullTime   `json:"start_of_work_time"`
	EndOfWorkTime      sql.NullTime   `json:"end_of_work_time"`
	BookedByUserID     sql.NullInt32  `json:"booked_by_user_id"`
	DispatchedByUserID sql.NullInt32  `json:"dispatched_by_user_id"`
	SoldByTechnicianID sql.NullInt32  `json:"sold_by_technician_id"`
	IsWarranty         sql.NullBool   `json:"is_warranty"`
	WarrantyForJobID   sql.NullInt32  `json:"warranty_for_job_id"`
	IsRecall           sql.NullBool   `json:"is_recall"`
	RecallForJobID     sql.NullInt32  `json:"recall_for_job_id"`
	JobSubtotal        interface{}    `json:"job_subtotal"`
	JobTotal           interface{}    `json:"job_total"`
	Revenue            interface{}    `json:"revenue"`
	IsZeroDollarJob    sql.NullBool   `json:"is_zero_dollar_job"`
}

func (q *Queries) GetJobWithFinancials(ctx context.Context, jobID int32) (GetJobWithFinancialsRow, error) {
	row := q.db.QueryRowContext(ctx, getJobWithFinancials, jobID)
	var i GetJobWithFinancialsRow
	err := row.Scan(
		&i.JobID,
		&i.JobTypeID,
		&i.BusinessUnitID,
		&i.CustomerID,
		&i.LocationID,
		&i.ProjectID,
		&i.JobCampaignID,
		&i.CallCampaignID,
		&i.JobStatus,
		&i.Priority,
		&i.Summary,
		&i.JobCreationDate,
		&i.JobScheduleDate,
		&i.JobCompletionDate,
		&i.ScheduledTime,
		&i.FirstDispatchDate,
		&i.HoldDate,
		&i.StartOfWorkTime,
		&i.EndOfWorkTime,
		&i.BookedByUserID,
		&i.DispatchedByUserID,
		&i.SoldByTechnicianID,
		&i.IsWarranty,
		&i.WarrantyForJobID,
		&i.IsRecall,
		&i.RecallForJobID,
		&i.JobSubtotal,
		&i.JobTotal,
		&i.Revenue,
		&i.IsZeroDollarJob,
	)
	return i, err
}

const getJobsByDateRangeWithTotals = `-- name: GetJobsByDateRangeWithTotals :many
SELECT 
    j.job_id,
    j.job_creation_date,
    j.job_status,
    c.customer_name,
    jfs.job_total,
    jfs.revenue
FROM job j
JOIN customer c ON j.customer_id = c.customer_id
LEFT JOIN vw_job_financial_summary jfs ON j.job_id = jfs.job_id
WHERE j.job_creation_date BETWEEN $1 AND $2
ORDER BY j.job_creation_date DESC
`

type GetJobsByDateRangeWithTotalsParams struct {
	JobCreationDate   time.Time `json:"job_creation_date"`
	JobCreationDate_2 time.Time `json:"job_creation_date_2"`
}

type GetJobsByDateRangeWithTotalsRow struct {
	JobID           int32       `json:"job_id"`
	JobCreationDate time.Time   `json:"job_creation_date"`
	JobStatus       string      `json:"job_status"`
	CustomerName    string      `json:"customer_name"`
	JobTotal        interface{} `json:"job_total"`
	Revenue         interface{} `json:"revenue"`
}

func (q *Queries) GetJobsByDateRangeWithTotals(ctx context.Context, arg GetJobsByDateRangeWithTotalsParams) ([]GetJobsByDateRangeWithTotalsRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobsByDateRangeWithTotals, arg.JobCreationDate, arg.JobCreationDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobsByDateRangeWithTotalsRow
	for rows.Next() {
		var i GetJobsByDateRangeWithTotalsRow
		if err := rows.Scan(
			&i.JobID,
			&i.JobCreationDate,
			&i.JobStatus,
			&i.CustomerName,
			&i.JobTotal,
			&i.Revenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobsWithFinancials = `-- name: GetJobsWithFinancials :many
SELECT 
    j.job_id, j.job_type_id, j.business_unit_id, j.customer_id, j.location_id, j.project_id, j.job_campaign_id, j.call_campaign_id, j.job_status, j.priority, j.summary, j.job_creation_date, j.job_schedule_date, j.job_completion_date, j.scheduled_time, j.first_dispatch_date, j.hold_date, j.start_of_work_time, j.end_of_work_time, j.booked_by_user_id, j.dispatched_by_user_id, j.sold_by_technician_id, j.is_warranty, j.warranty_for_job_id, j.is_recall, j.recall_for_job_id,
    jfs.job_subtotal,
    jfs.job_total,
    jfs.revenue,
    jfs.is_zero_dollar_job
FROM job j
LEFT JOIN vw_job_financial_summary jfs ON j.job_id = jfs.job_id
WHERE j.job_status = $1
ORDER BY j.job_creation_date DESC
LIMIT $2 OFFSET $3
`

type GetJobsWithFinancialsParams struct {
	JobStatus string `json:"job_status"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type GetJobsWithFinancialsRow struct {
	JobID              int32          `json:"job_id"`
	JobTypeID          int32          `json:"job_type_id"`
	BusinessUnitID     int32          `json:"business_unit_id"`
	CustomerID         int32          `json:"customer_id"`
	LocationID         int32          `json:"location_id"`
	ProjectID          sql.NullInt32  `json:"project_id"`
	JobCampaignID      sql.NullInt32  `json:"job_campaign_id"`
	CallCampaignID     sql.NullInt32  `json:"call_campaign_id"`
	JobStatus          string         `json:"job_status"`
	Priority           sql.NullString `json:"priority"`
	Summary            sql.NullString `json:"summary"`
	JobCreationDate    time.Time      `json:"job_creation_date"`
	JobScheduleDate    sql.NullTime   `json:"job_schedule_date"`
	JobCompletionDate  sql.NullTime   `json:"job_completion_date"`
	ScheduledTime      sql.NullTime   `json:"scheduled_time"`
	FirstDispatchDate  sql.NullTime   `json:"first_dispatch_date"`
	HoldDate           sql.NullTime   `json:"hold_date"`
	StartOfWorkTime    sql.NullTime   `json:"start_of_work_time"`
	EndOfWorkTime      sql.NullTime   `json:"end_of_work_time"`
	BookedByUserID     sql.NullInt32  `json:"booked_by_user_id"`
	DispatchedByUserID sql.NullInt32  `json:"dispatched_by_user_id"`
	SoldByTechnicianID sql.NullInt32  `json:"sold_by_technician_id"`
	IsWarranty         sql.NullBool   `json:"is_warranty"`
	WarrantyForJobID   sql.NullInt32  `json:"warranty_for_job_id"`
	IsRecall           sql.NullBool   `json:"is_recall"`
	RecallForJobID     sql.NullInt32  `json:"recall_for_job_id"`
	JobSubtotal        interface{}    `json:"job_subtotal"`
	JobTotal           interface{}    `json:"job_total"`
	Revenue            interface{}    `json:"revenue"`
	IsZeroDollarJob    sql.NullBool   `json:"is_zero_dollar_job"`
}

func (q *Queries) GetJobsWithFinancials(ctx context.Context, arg GetJobsWithFinancialsParams) ([]GetJobsWithFinancialsRow, error) {
	rows, err := q.db.QueryContext(ctx, getJobsWithFinancials, arg.JobStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetJobsWithFinancialsRow
	for rows.Next() {
		var i GetJobsWithFinancialsRow
		if err := rows.Scan(
			&i.JobID,
			&i.JobTypeID,
			&i.BusinessUnitID,
			&i.CustomerID,
			&i.LocationID,
			&i.ProjectID,
			&i.JobCampaignID,
			&i.CallCampaignID,
			&i.JobStatus,
			&i.Priority,
			&i.Summary,
			&i.JobCreationDate,
			&i.JobScheduleDate,
			&i.JobCompletionDate,
			&i.ScheduledTime,
			&i.FirstDispatchDate,
			&i.HoldDate,
			&i.StartOfWorkTime,
			&i.EndOfWorkTime,
			&i.BookedByUserID,
			&i.DispatchedByUserID,
			&i.SoldByTechnicianID,
			&i.IsWarranty,
			&i.WarrantyForJobID,
			&i.IsRecall,
			&i.RecallForJobID,
			&i.JobSubtotal,
			&i.JobTotal,
			&i.Revenue,
			&i.IsZeroDollarJob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueByBusinessUnit = `-- name: GetRevenueByBusinessUnit :many
SELECT 
    bu.business_unit_name,
    COUNT(DISTINCT j.job_id) as total_jobs,
    COALESCE(SUM(jfs.revenue), 0) as total_revenue,
    COALESCE(AVG(jfs.revenue), 0) as avg_revenue_per_job
FROM business_unit bu
LEFT JOIN job j ON bu.business_unit_id = j.business_unit_id
LEFT JOIN vw_job_financial_summary jfs ON j.job_id = jfs.job_id
WHERE j.job_status = 'Completed'
    AND j.job_completion_date BETWEEN $1 AND $2
GROUP BY bu.business_unit_id, bu.business_unit_name
ORDER BY total_revenue DESC
`

type GetRevenueByBusinessUnitParams struct {
	JobCompletionDate   sql.NullTime `json:"job_completion_date"`
	JobCompletionDate_2 sql.NullTime `json:"job_completion_date_2"`
}

type GetRevenueByBusinessUnitRow struct {
	BusinessUnitName string      `json:"business_unit_name"`
	TotalJobs        int64       `json:"total_jobs"`
	TotalRevenue     interface{} `json:"total_revenue"`
	AvgRevenuePerJob interface{} `json:"avg_revenue_per_job"`
}

func (q *Queries) GetRevenueByBusinessUnit(ctx context.Context, arg GetRevenueByBusinessUnitParams) ([]GetRevenueByBusinessUnitRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevenueByBusinessUnit, arg.JobCompletionDate, arg.JobCompletionDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueByBusinessUnitRow
	for rows.Next() {
		var i GetRevenueByBusinessUnitRow
		if err := rows.Scan(
			&i.BusinessUnitName,
			&i.TotalJobs,
			&i.TotalRevenue,
			&i.AvgRevenuePerJob,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTechnicianPerformance = `-- name: GetTechnicianPerformance :many
SELECT 
    t.technician_id,
    t.technician_name,
    COUNT(DISTINCT jt.job_id) as total_jobs,
    COALESCE(SUM(jt.hours_worked), 0) as total_hours,
    COALESCE(AVG(s.survey_score), 0) as avg_survey_score
FROM technician t
LEFT JOIN job_technician jt ON t.technician_id = jt.technician_id
LEFT JOIN survey s ON jt.job_id = s.job_id
WHERE jt.split_percentage > 0
GROUP BY t.technician_id, t.technician_name
ORDER BY total_jobs DESC
`

type GetTechnicianPerformanceRow struct {
	TechnicianID   int32       `json:"technician_id"`
	TechnicianName string      `json:"technician_name"`
	TotalJobs      int64       `json:"total_jobs"`
	TotalHours     interface{} `json:"total_hours"`
	AvgSurveyScore interface{} `json:"avg_survey_score"`
}

func (q *Queries) GetTechnicianPerformance(ctx context.Context) ([]GetTechnicianPerformanceRow, error) {
	rows, err := q.db.QueryContext(ctx, getTechnicianPerformance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTechnicianPerformanceRow
	for rows.Next() {
		var i GetTechnicianPerformanceRow
		if err := rows.Scan(
			&i.TechnicianID,
			&i.TechnicianName,
			&i.TotalJobs,
			&i.TotalHours,
			&i.AvgSurveyScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
