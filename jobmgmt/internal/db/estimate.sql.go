// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: estimate.sql

package db

import (
	"context"
	"database/sql"
)

const createEstimate = `-- name: CreateEstimate :one
INSERT INTO estimates (id, name, description, subtotal, is_sold, invoices_id, opportunities_id, jobs_id, sold_on_date, created_at, updated_at)
VALUES (
    $1, 
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    NOW(),
    NOW()
)
RETURNING id, name, description, subtotal, is_sold, sold_by, invoices_id, opportunities_id, jobs_id, sold_on_date, created_at, updated_at
`

type CreateEstimateParams struct {
	ID              int32          `json:"id"`
	Name            string         `json:"name"`
	Description     sql.NullString `json:"description"`
	Subtotal        sql.NullString `json:"subtotal"`
	IsSold          sql.NullBool   `json:"is_sold"`
	InvoicesID      sql.NullInt32  `json:"invoices_id"`
	OpportunitiesID sql.NullInt32  `json:"opportunities_id"`
	JobsID          sql.NullInt32  `json:"jobs_id"`
	SoldOnDate      sql.NullTime   `json:"sold_on_date"`
}

func (q *Queries) CreateEstimate(ctx context.Context, arg CreateEstimateParams) (Estimate, error) {
	row := q.db.QueryRowContext(ctx, createEstimate,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Subtotal,
		arg.IsSold,
		arg.InvoicesID,
		arg.OpportunitiesID,
		arg.JobsID,
		arg.SoldOnDate,
	)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Subtotal,
		&i.IsSold,
		&i.SoldBy,
		&i.InvoicesID,
		&i.OpportunitiesID,
		&i.JobsID,
		&i.SoldOnDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEstimateByID = `-- name: GetEstimateByID :one
SELECT id, name, description, subtotal, is_sold, sold_by, invoices_id, opportunities_id, jobs_id, sold_on_date, created_at, updated_at FROM estimates WHERE id = $1
`

func (q *Queries) GetEstimateByID(ctx context.Context, id int32) (Estimate, error) {
	row := q.db.QueryRowContext(ctx, getEstimateByID, id)
	var i Estimate
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Subtotal,
		&i.IsSold,
		&i.SoldBy,
		&i.InvoicesID,
		&i.OpportunitiesID,
		&i.JobsID,
		&i.SoldOnDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEstimatesByJobID = `-- name: GetEstimatesByJobID :many
SELECT id, name, description, subtotal, is_sold, sold_by, invoices_id, opportunities_id, jobs_id, sold_on_date, created_at, updated_at FROM estimates WHERE jobs_id = $1 ORDER BY created_at
`

func (q *Queries) GetEstimatesByJobID(ctx context.Context, jobsID sql.NullInt32) ([]Estimate, error) {
	rows, err := q.db.QueryContext(ctx, getEstimatesByJobID, jobsID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Estimate
	for rows.Next() {
		var i Estimate
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Subtotal,
			&i.IsSold,
			&i.SoldBy,
			&i.InvoicesID,
			&i.OpportunitiesID,
			&i.JobsID,
			&i.SoldOnDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEstimateSold = `-- name: UpdateEstimateSold :exec
UPDATE estimates
SET is_sold = $2, sold_on_date = $3
WHERE id = $1
`

type UpdateEstimateSoldParams struct {
	ID         int32        `json:"id"`
	IsSold     sql.NullBool `json:"is_sold"`
	SoldOnDate sql.NullTime `json:"sold_on_date"`
}

func (q *Queries) UpdateEstimateSold(ctx context.Context, arg UpdateEstimateSoldParams) error {
	_, err := q.db.ExecContext(ctx, updateEstimateSold, arg.ID, arg.IsSold, arg.SoldOnDate)
	return err
}
