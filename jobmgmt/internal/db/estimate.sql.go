// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: estimate.sql

package db

import (
	"context"
	"database/sql"
)

const createEstimate = `-- name: CreateEstimate :one

INSERT INTO estimate (job_id, estimate_subtotal, is_sold, sold_on_date)
VALUES ($1, $2, $3, $4)
RETURNING estimate_id, job_id, estimate_subtotal, is_sold, sold_on_date, created_at
`

type CreateEstimateParams struct {
	JobID            int32        `json:"job_id"`
	EstimateSubtotal string       `json:"estimate_subtotal"`
	IsSold           sql.NullBool `json:"is_sold"`
	SoldOnDate       sql.NullTime `json:"sold_on_date"`
}

// =====================================================
// ESTIMATE QUERIES
// =====================================================
func (q *Queries) CreateEstimate(ctx context.Context, arg CreateEstimateParams) (Estimate, error) {
	row := q.db.QueryRowContext(ctx, createEstimate,
		arg.JobID,
		arg.EstimateSubtotal,
		arg.IsSold,
		arg.SoldOnDate,
	)
	var i Estimate
	err := row.Scan(
		&i.EstimateID,
		&i.JobID,
		&i.EstimateSubtotal,
		&i.IsSold,
		&i.SoldOnDate,
		&i.CreatedAt,
	)
	return i, err
}

const getEstimateByID = `-- name: GetEstimateByID :one
SELECT estimate_id, job_id, estimate_subtotal, is_sold, sold_on_date, created_at FROM estimate WHERE estimate_id = $1
`

func (q *Queries) GetEstimateByID(ctx context.Context, estimateID int32) (Estimate, error) {
	row := q.db.QueryRowContext(ctx, getEstimateByID, estimateID)
	var i Estimate
	err := row.Scan(
		&i.EstimateID,
		&i.JobID,
		&i.EstimateSubtotal,
		&i.IsSold,
		&i.SoldOnDate,
		&i.CreatedAt,
	)
	return i, err
}

const getEstimatesByJobID = `-- name: GetEstimatesByJobID :many
SELECT estimate_id, job_id, estimate_subtotal, is_sold, sold_on_date, created_at FROM estimate WHERE job_id = $1 ORDER BY created_at
`

func (q *Queries) GetEstimatesByJobID(ctx context.Context, jobID int32) ([]Estimate, error) {
	rows, err := q.db.QueryContext(ctx, getEstimatesByJobID, jobID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Estimate
	for rows.Next() {
		var i Estimate
		if err := rows.Scan(
			&i.EstimateID,
			&i.JobID,
			&i.EstimateSubtotal,
			&i.IsSold,
			&i.SoldOnDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEstimateSold = `-- name: UpdateEstimateSold :exec
UPDATE estimate 
SET is_sold = $2, sold_on_date = $3
WHERE estimate_id = $1
`

type UpdateEstimateSoldParams struct {
	EstimateID int32        `json:"estimate_id"`
	IsSold     sql.NullBool `json:"is_sold"`
	SoldOnDate sql.NullTime `json:"sold_on_date"`
}

func (q *Queries) UpdateEstimateSold(ctx context.Context, arg UpdateEstimateSoldParams) error {
	_, err := q.db.ExecContext(ctx, updateEstimateSold, arg.EstimateID, arg.IsSold, arg.SoldOnDate)
	return err
}
